using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace ConsoleApp17
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Категория 4: Lock Synchronization 
            #region Задание 31-32: lock для защиты общей переменной и критическая секция
            Console.WriteLine("Задание 31-32: lock и критическая секция со счётчиком");
            int sharedCounter = 0;
            object lockObj = new object();
            int threadCount = 10;
            int iterations = 10000;

            Thread[] threads31 = new Thread[threadCount];
            for (int i = 0; i < threadCount; i++)
            {
                threads31[i] = new Thread(() =>
                {
                    for (int j = 0; j < iterations; j++)
                    {
                        lock (lockObj)
                        {
                            sharedCounter++;
                        }
                    }
                });
                threads31[i].Start();
            }
            foreach (var t in threads31) t.Join();
            Console.WriteLine($"Ожидаемое: {threadCount * iterations}, Фактическое: {sharedCounter}\n");
            #endregion

            #region Задание 33: Демонстрация deadlock с вложенными lock
            Console.WriteLine("Задание 33: Deadlock с двумя вложенными lock");
            object lockA = new object();
            object lockB = new object();

            Thread tDeadlock1 = new Thread(() =>
            {
                lock (lockA)
                {
                    Thread.Sleep(100);
                    Console.WriteLine("Поток 1 захватил lockA, ждёт lockB...");
                    lock (lockB)
                    {
                        Console.WriteLine("Поток 1 захватил lockB");
                    }
                }
            });

            Thread tDeadlock2 = new Thread(() =>
            {
                lock (lockB)
                {
                    Thread.Sleep(100);
                    Console.WriteLine("Поток 2 захватил lockB, ждёт lockA...");
                    lock (lockA)
                    {
                        Console.WriteLine("Поток 2 захватил lockA");
                    }
                }
            });

            tDeadlock1.Start();
            tDeadlock2.Start();

            Thread.Sleep(3000); // Даем время на deadlock
            Console.WriteLine("Deadlock произошёл! (программа зависла бы, если не прервать)\n");
            // Принудительно завершаем (в реальности — избегайте такого)
            tDeadlock1.Abort();
            tDeadlock2.Abort();
            #endregion

            #region Задание 34: Избежание deadlock — фиксированный порядок блокировок
            Console.WriteLine("Задание 34: Избежание deadlock — фиксированный порядок");
            object lock1 = new object();
            object lock2 = new object();

            Thread safe1 = new Thread(() =>
            {
                lock (lock1)
                {
                    Console.WriteLine("Безопасный поток 1: захватил lock1");
                    lock (lock2)
                    {
                        Console.WriteLine("Безопасный поток 1: захватил lock2");
                    }
                }
            });

            Thread safe2 = new Thread(() =>
            {
                lock (lock1)  // Всегда сначала lock1, потом lock2
                {
                    Console.WriteLine("Безопасный поток 2: захватил lock1");
                    lock (lock2)
                    {
                        Console.WriteLine("Безопасный поток 2: захватил lock2");
                    }
                }
            });

            safe1.Start(); safe2.Start();
            safe1.Join(); safe2.Join();
            Console.WriteLine("Deadlock избежан!\n");
            #endregion

            #region Задание 35: lock с разными объектами для разных данных
            Console.WriteLine("Задание 35: Разные lock для разных ресурсов");
            int counterA = 0; object lockA35 = new object();
            int counterB = 0; object lockB35 = new object();

            Thread[] threads35 = new Thread[8];
            for (int i = 0; i < threads35.Length; i++)
            {
                bool useA = i % 2 == 0;
                threads35[i] = new Thread(() =>
                {
                    for (int j = 0; j < 5000; j++)
                    {
                        if (useA) { lock (lockA35) counterA++; }
                        else { lock (lockB35) counterB++; }
                    }
                });
                threads35[i].Start();
            }
            foreach (var t in threads35) t.Join();
            Console.WriteLine($"counterA = {counterA}, counterB = {counterB}\n");
            #endregion

            #region Задание 36: Потокобезопасный класс Counter
            Console.WriteLine("Задание 36: Потокобезопасный Counter");
            var safeCounter = new ThreadSafeCounter();
            Thread[] threads36 = Enumerable.Range(0, 10).Select(_ => new Thread(() =>
            {
                for (int i = 0; i < 10000; i++) safeCounter.Increment();
            })).ToArray();

            foreach (var t in threads36) t.Start();
            foreach (var t in threads36) t.Join();
            Console.WriteLine($"ThreadSafeCounter = {safeCounter.Value}\n");
            #endregion

            #region Задание 37: ReaderWriterLockSlim
            Console.WriteLine("Задание 37: ReaderWriterLockSlim (много читателей, редкие писатели)");
            var rwCounter = new ReaderWriterCounter();
            var tasks = new List<Task>();
            for (int i = 0; i < 10; i++)
                tasks.Add(Task.Run(() => { for (int j = 0; j < 1000; j++) rwCounter.Read(); }));
            tasks.Add(Task.Run(() => { Thread.Sleep(100); rwCounter.Write(999); }));
            Task.WaitAll(tasks.ToArray());
            Console.WriteLine($"ReaderWriterCounter = {rwCounter.Value}\n");
            #endregion

            #region Задание 38: Сравнение производительности lock vs Interlocked vs Concurrent
            Console.WriteLine("Задание 38: Сравнение производительности");
            var sw = Stopwatch.StartNew();
            long lockSum = 0; object lockPerf = new object();
            Parallel.For(0, 10_000_000, i => { lock (lockPerf) lockSum++; });
            sw.Stop();
            Console.WriteLine($"lock:     {sw.ElapsedMilliseconds} мс");

            sw.Restart();
            long interlockedSum = 0;
            Parallel.For(0, 10_000_000, i => Interlocked.Increment(ref interlockedSum));
            sw.Stop();
            Console.WriteLine($"Interlocked: {sw.ElapsedMilliseconds} мс");

            sw.Restart();
            var concurrentBag = new ConcurrentBag<int>();
            Parallel.For(0, 10_000_000, i => concurrentBag.Add(i));
            sw.Stop();
            Console.WriteLine($"ConcurrentBag: {sw.ElapsedMilliseconds} мс\n");
            #endregion

            #region Задание 39: lock для защиты коллекции
            Console.WriteLine("Задание 39: lock для List<T>");
            var sharedList = new List<int>();
            object listLock = new object();

            Parallel.Invoke(
                () => { for (int i = 0; i < 10000; i++) { lock (listLock) sharedList.Add(i); } },
                () => { for (int i = 0; i < 10000; i++) { lock (listLock) sharedList.Add(-i); } }
            );
            Console.WriteLine($"Элементов в списке: {sharedList.Count}\n");
            #endregion

            #region Задание 40: Паттерн "Читатели-писатели" с lock (простая версия)
            Console.WriteLine("Задание 40: Паттерн Читатели-Писатели (с lock)");
            var rwSimple = new ReadersWritersSimple();
            var tRead1 = Task.Run(() => rwSimple.Read());
            var tRead2 = Task.Run(() => rwSimple.Read());
            var tWrite = Task.Run(() => { Thread.Sleep(100); rwSimple.Write(42); });
            Task.WaitAll(tRead1, tRead2, tWrite);
            Console.WriteLine($"Читатели-писатели: значение = {rwSimple.Value}\n");
            #endregion

            // Категория 5: Mutex & Semaphore
            #region Задание 41-42: Mutex и WaitOne
            Console.WriteLine("Задание 41-42: Mutex с WaitOne");
            using (var mutex = new Mutex(false, "MyAppMutexDemo"))
            {
                if (mutex.WaitOne(1000))
                {
                    Console.WriteLine("Mutex захвачен");
                    Thread.Sleep(500);
                    mutex.ReleaseMutex();
                }
            }
            Console.WriteLine();
            #endregion

            #region Задание 43-44: Semaphore (ограничение потоков)
            Console.WriteLine("Задание 43-44: Semaphore (макс. 3 потока одновременно)");
            var semaphore = new Semaphore(3, 3);
            Thread[] threadsSem = new Thread[10];
            for (int i = 0; i < 10; i++)
            {
                int id = i;
                threadsSem[i] = new Thread(() =>
                {
                    semaphore.WaitOne();
                    Console.WriteLine($"Поток {id} вошёл в ограниченную зону");
                    Thread.Sleep(800);
                    Console.WriteLine($"Поток {id} вышел");
                    semaphore.Release();
                });
                threadsSem[i].Start();
            }
            foreach (var t in threadsSem) t.Join();
            Console.WriteLine();
            #endregion

            #region Задание 45: SemaphoreSlim (асинхронный)
            Console.WriteLine("Задание 45: SemaphoreSlim + await");
            var semSlim = new SemaphoreSlim(2, 2);
            async Task UseResourceAsync(int id)
            {
                await semSlim.WaitAsync();
                try
                {
                    Console.WriteLine($"Async поток {id} работает с ресурсом");
                    await Task.Delay(600);
                }
                finally
                {
                    semSlim.Release();
                }
            }
            Task.WaitAll(Enumerable.Range(0, 6).Select(UseResourceAsync).ToArray());
            Console.WriteLine();
            #endregion

            #region Задание 46: AbandonedMutexException
            Console.WriteLine("Задание 46: AbandonedMutexException");
            var mutexAbandoned = new Mutex(true, "AbandonedTest");
            Thread tAbandon = new Thread(() =>
            {
                // Поток захватил мьютекс и "умер" не освободив
            });
            tAbandon.Start();
            GC.Collect();
            GC.WaitForPendingFinalizers();
            try
            {
                mutexAbandoned.WaitOne();
                Console.WriteLine("Мьютекс был брошен, но мы его получили");
            }
            catch (AbandonedMutexException)
            {
                Console.WriteLine("Поймано AbandonedMutexException");
            }
            finally
            {
                mutexAbandoned.ReleaseMutex();
            }
            Console.WriteLine();
            #endregion

            #region Задание 47: Named Mutex между процессами
            Console.WriteLine("Задание 47: Named Mutex (межпроцессный)");
            bool createdNew;
            using (var globalMutex = new Mutex(true, @"Global\MyInterProcessMutex", out createdNew))
            {
                if (createdNew)
                {
                    Console.WriteLine("Это первый экземпляр приложения");
                    Thread.Sleep(2000);
                }
                else
                {
                    Console.WriteLine("Приложение уже запущено!");
                }
            }
            Console.WriteLine();
            #endregion

            #region Задание 49: CountdownEvent
            Console.WriteLine("Задание 49: CountdownEvent");
            var countdown = new CountdownEvent(5);
            for (int i = 0; i < 5; i++)
            {
                int id = i;
                ThreadPool.QueueUserWorkItem(_ =>
                {
                    Thread.Sleep(300);
                    Console.WriteLine($"Рабочий {id} завершён");
                    countdown.Signal();
                });
            }
            countdown.Wait();
            Console.WriteLine("Все рабочие завершили работу\n");
            #endregion

            #region Задание 50: ManualResetEvent
            Console.WriteLine("Задание 50: ManualResetEvent");
            var mre = new ManualResetEvent(false);
            Thread worker = new Thread(() =>
            {
                Console.WriteLine("Рабочий ждёт сигнала...");
                mre.WaitOne();
                Console.WriteLine("Сигнал получен — работаем!");
            });
            worker.Start();
            Thread.Sleep(1000);
            mre.Set(); // Разблокируем
            worker.Join();
            Console.WriteLine();
            #endregion

            // Категория 6: CancellationToken
            #region Задание 51-53,55: CancellationToken + ThrowIfCancellationRequested
            Console.WriteLine("Задание 51-53,55: Отмена через CancellationToken");
            var cts = new CancellationTokenSource();
            Task.Run(() =>
            {
                try
                {
                    for (int i = 0; i < 100; i++)
                    {
                        cts.Token.ThrowIfCancellationRequested();
                        Thread.Sleep(100);
                        Console.WriteLine($"Работаем... {i}");
                    }
                }
                catch (OperationCanceledException)
                {
                    Console.WriteLine("Операция отменена!");
                }
            }, cts.Token);

            Thread.Sleep(500);
            cts.Cancel();
            Thread.Sleep(500);
            Console.WriteLine();
            #endregion

            #region Задание 54: Таймаут через CancellationTokenSource
            Console.WriteLine("Задание 54: Автоматическая отмена по таймауту");
            var ctsTimeout = new CancellationTokenSource(1000);
            Task.Run(() =>
            {
                try
                {
                    while (true)
                    {
                        ctsTimeout.Token.ThrowIfCancellationRequested();
                        Thread.Sleep(200);
                        Console.WriteLine("Долгая операция...");
                    }
                }
                catch (OperationCanceledException)
                {
                    Console.WriteLine("Таймаут! Операция отменена.");
                }
            }, ctsTimeout.Token);
            Thread.Sleep(1500);
            Console.WriteLine();
            #endregion

            #region Задание 56: Register() — действие при отмене
            Console.WriteLine("Задание 56: Register() — callback при отмене");
            var ctsReg = new CancellationTokenSource();
            ctsReg.Token.Register(() => Console.WriteLine("Callback: отмена запрошена!"));
            Thread.Sleep(500);
            ctsReg.Cancel();
            Thread.Sleep(200);
            Console.WriteLine();
            #endregion

            #region Задание 57: CancellationToken в Task.Delay и других API
            Console.WriteLine("Задание 57: Task.Delay с CancellationToken");
            var ctsDelay = new CancellationTokenSource(700);
            Task.Delay(5000, ctsDelay.Token).ContinueWith(t =>
            {
                if (t.IsCanceled)
                    Console.WriteLine("Task.Delay был отменён!");
            });
            ctsDelay.Cancel();
            Thread.Sleep(300);
            Console.WriteLine();
            #endregion

            #region Задание 58: Graceful shutdown с CancellationToken
            Console.WriteLine("Задание 58: Graceful shutdown приложения");
            var shutdownCts = new CancellationTokenSource();
            var workerTask = Task.Run(() =>
            {
                while (!shutdownCts.Token.IsCancellationRequested)
                {
                    Console.WriteLine("Сервер работает...");
                    Thread.Sleep(400);
                }
                Console.WriteLine("Получен сигнал завершения — graceful shutdown...");
                Thread.Sleep(800); // имитация сохранения состояния
                Console.WriteLine("Сервер корректно завершён.");
            }, shutdownCts.Token);

            Thread.Sleep(2000);
            Console.WriteLine("Нажмите Enter для завершения сервера...");
            Console.ReadLine();
            shutdownCts.Cancel();
            workerTask.Wait();
            Console.WriteLine();
            #endregion

            Console.WriteLine("=== Все задания 31–58 выполнены успешно! ===");
            Console.ReadLine();
        }

        // Вспомогательные классы
        class ThreadSafeCounter
        {
            private int _value = 0;
            private readonly object _lock = new object();
            public void Increment() { lock (_lock) _value++; }
            public int Value => _value;
        }

        class ReaderWriterCounter
        {
            private int _value = 0;
            private readonly ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();

            public int Read()
            {
                _rw.EnterReadLock();
                try { return _value; }
                finally { _rw.ExitReadLock(); }
            }

            public void Write(int val)
            {
                _rw.EnterWriteLock();
                try { _value = val; Console.WriteLine($"Записано новое значение: {val}"); }
                finally { _rw.ExitWriteLock(); }
            }

            public int Value
            {
                get { _rw.EnterReadLock(); try { return _value; } finally { _rw.ExitReadLock(); } }
            }
        }

        class ReadersWritersSimple
        {
            private int _value = 0;
            private int _readers = 0;
            private readonly object _lock = new object();

            public int Read()
            {
                lock (_lock)
                {
                    _readers++;
                    if (_readers == 1) Monitor.Wait(_lock); // блокируем запись
                }
                try { return _value; }
                finally
                {
                    lock (_lock)
                    {
                        _readers--;
                        if (_readers == 0) Monitor.PulseAll(_lock);
                    }
                }
            }

            public void Write(int val)
            {
                lock (_lock)
                {
                    Monitor.PulseAll(_lock); // разблокируем читателей
                    Monitor.Wait(_lock);     // ждём пока все читатели уйдут
                    _value = val;
                    Console.WriteLine($"Писатель записал: {val}");
                    Monitor.PulseAll(_lock);
                }
            }

            public int Value => _value;
        }
    }
}
